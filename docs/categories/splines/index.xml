<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Splines on Dr. Scott Spencer</title>
    <link>https://ssp3nc3r.github.io/categories/splines/</link>
    <description>Recent content in Splines on Dr. Scott Spencer</description>
    <generator>Hugo</generator>
    <language>en</language>
    <lastBuildDate>Mon, 24 Nov 2025 11:17:09 -0500</lastBuildDate>
    <atom:link href="https://ssp3nc3r.github.io/categories/splines/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Speedy splines part two, derivative work</title>
      <link>https://ssp3nc3r.github.io/post/derivative-work-on-speedy-splines/</link>
      <pubDate>Thu, 31 Aug 2023 00:00:00 +0000</pubDate>
      <guid>https://ssp3nc3r.github.io/post/derivative-work-on-speedy-splines/</guid>
      <description>&lt;p&gt;In the last post, I showed how we can speed up computation for splines in Stan. This post is, ahem, derivative. Perhaps we have noisy data of position and time, and we want to estimate speed and acceleration. We can use b-splines and their derivatives for this.&lt;/p&gt;&#xA;&lt;p&gt;So let’s pick up where we left off, and add calculations in Stan to calculate the first and second derivatives of the spline in Stan. Much of the code below mirrors that of the previous post. There are multiple approaches to calculating derivatives of splines. We can take the derivative of the basis functions &lt;span class=&#34;citation&#34;&gt;(&lt;a href=&#34;#ref-rogers2001&#34;&gt;Rogers 2001, sec. 3.10&lt;/a&gt; B-Spline Curve Derivatives)&lt;/span&gt; or we can difference the coefficients &lt;span class=&#34;citation&#34;&gt;(&lt;a href=&#34;#ref-deboor2001&#34;&gt;Boor 2001&lt;/a&gt;, X. The Stable Evaluation of B-Splines and Splines)&lt;/span&gt;. In the Stan functions block below, I’ve added calculations for the first and second derivatives of the basis functions.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Speedy splines in Stan part one</title>
      <link>https://ssp3nc3r.github.io/post/speedy-splines-in-stan/</link>
      <pubDate>Wed, 16 Aug 2023 00:00:00 +0000</pubDate>
      <guid>https://ssp3nc3r.github.io/post/speedy-splines-in-stan/</guid>
      <description>&lt;p&gt;Milad Kharratzadeh provides a helpful &lt;a href=&#34;https://mc-stan.org/users/documentation/case-studies/splines_in_stan.html&#34;&gt;case study&lt;/a&gt; on estimating splines in Stan. We can improve on his work with a few tricks to speed up the estimation process. Namely, if we decompose the spline matrix using QR decomposition, we speed up Stan’s fitting process by at least an order of magnitude.&lt;/p&gt;&#xA;&lt;p&gt;Here’s how we can alter the code to accommodate splines with a few tricks to speed things up:&lt;/p&gt;&#xA;&lt;pre class=&#34;stan&#34;&gt;&lt;code&gt;&#xA;functions {&#xA;  &#xA;  vector build_b_spline(vector t, array[] real ext_knots, int ind, int order) {&#xA;    &#xA;    vector[size(t)] b_spline;&#xA;    vector[size(t)] w1 = rep_vector(0, size(t));&#xA;    vector[size(t)] w2 = rep_vector(0, size(t));&#xA;    &#xA;    if (order == 1)&#xA;    &#xA;      for (i in 1:size(t)) &#xA;        b_spline[i] = (ext_knots[ind] &amp;lt;= t[i]) &amp;amp;&amp;amp; (t[i] &amp;lt; ext_knots[ind+1]); &#xA;    &#xA;    else {&#xA;    &#xA;      if (ext_knots[ind] != ext_knots[ind + order-1])&#xA;        w1 = (t - rep_vector(ext_knots[ind], size(t))) / &#xA;             (ext_knots[ind + order-1] - ext_knots[ind]);&#xA;      if (ext_knots[ind + 1] != ext_knots[ind + order])&#xA;        w2 = 1 - (t - rep_vector(ext_knots[ind + 1], size(t))) / &#xA;                 (ext_knots[ind + order] - ext_knots[ind + 1]);&#xA;                 &#xA;      b_spline = w1 .* build_b_spline(t, ext_knots, ind, order - 1) + &#xA;                 w2 .* build_b_spline(t, ext_knots, ind+1, order - 1);&#xA;    &#xA;    }&#xA;    &#xA;    return b_spline;&#xA;  &#xA;  }&#xA;  &#xA;}&#xA;&#xA;&#xA;data {&#xA;  &#xA;  int&amp;lt;lower=1&amp;gt; T;                 // number of times measured&#xA;  vector[T] t;                    // remove and replace with position&#xA;  vector[T] y;                    // the measurement at each time point t&#xA;  &#xA;  int&amp;lt;lower=1&amp;gt; K;                 // number of knots&#xA;  int&amp;lt;lower=1&amp;gt; degree;            // degree of the spline&#xA;  int&amp;lt;lower=0,upper=1&amp;gt; penalized; // whether to use prior for smoothing&#xA;  &#xA;}&#xA;&#xA;&#xA;transformed data {&#xA;  &#xA;  // knots at evenly-spaced quantiles of data&#xA;  array[K] real p;&#xA;  for(i in 1:K) p[i] = (i - 1.0) / (K-1.0);&#xA;  array[K] real k = quantile(t, p);&#xA;  &#xA;  // build the spline matrix B&#xA;  int n_basis = K + degree - 1; &#xA;  matrix[n_basis, T] B;&#xA;  &#xA;  array[2 * degree + K] real ext_knots =&#xA;  append_array(append_array(rep_array(k[1], degree), k), rep_array(k[K], degree));&#xA;  &#xA;  for (ind in 1:n_basis)&#xA;    B[ind,:] = to_row_vector(build_b_spline(t, (ext_knots), ind, degree + 1));&#xA;  &#xA;  B[K + degree - 1, T] = 1;&#xA;  &#xA;  // QR decomposition of B, thin and scale&#xA;  matrix[T, n_basis] Q_ast = qr_thin_Q(B&amp;#39;) * sqrt(T - 1);&#xA;  matrix[n_basis, n_basis] R_ast = qr_thin_R(B&amp;#39;) / sqrt(T - 1);&#xA;  matrix[n_basis, n_basis] R_ast_inverse = inverse(R_ast);&#xA;  &#xA;  // helper stuff&#xA;  vector[T] zeros_T = rep_vector(0, T);&#xA;  &#xA;}&#xA;&#xA;&#xA;parameters {&#xA;  &#xA;  vector[n_basis] theta_raw; // coefficients on Q_ast&#xA;  real&amp;lt;lower=0&amp;gt; sigma;       // scale of the variation&#xA;  real&amp;lt;lower=0&amp;gt; tau;         // penalization on wiggles&#xA;  &#xA;}&#xA;&#xA;&#xA;transformed parameters {&#xA;  &#xA;  vector[n_basis] theta;&#xA;  &#xA;  if(penalized) {&#xA;    theta[1] = theta_raw[1];&#xA;    for(i in 2:n_basis) theta[i] = theta[i-1] + theta_raw[i] * tau;&#xA;  } else {&#xA;    theta = theta_raw;&#xA;  }&#xA;  &#xA;}&#xA;&#xA;&#xA;model {&#xA;  &#xA;  theta_raw ~ normal(0, 1);&#xA;  tau ~ normal(0, 1);&#xA;  sigma ~ exponential(1);  &#xA;  y ~ normal_id_glm(Q_ast, zeros_T, theta, sigma);&#xA;&#xA;}&#xA;&#xA;generated quantities {&#xA;  vector[n_basis] beta;&#xA;  beta = R_ast_inverse * theta;&#xA;  vector[T] y_hat = B&amp;#39; * beta;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;We can compile the model like so,&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
